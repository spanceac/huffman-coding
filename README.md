# Huffman encoder/decoder

## What is it
Huffman encoding lets you do lossless data compression alas not very effiecient.

The algorithm is explained in the wiki article with great examples:
https://en.wikipedia.org/wiki/Huffman_coding

## Why
I started this project because I wanted to store some audio data in a microcontroller with 128KB of flash memory.

After implementation, I discovered that the compression ratio is not great so it doesn't help too much. But it was a great programming exercise.

 This is my implementation of the algorithm.
 
## High level description
 When the code is compiled two binaries are generated:
 - **huf-encode-file**  the encoder binary
 - **huf-decode-file** the decoder binary
 
 The encoder binary takes as argument a file path and generates two files:
 - **encoded.out** which is the Huffman encoded data
 - **tree.out** which contains the code dictionary(Huffman tree) that will be needed by the decoder to decode the data
 
 The decoder binary takes as arguments two file paths:
 - the code dictionary generated by the encoder binary
 - the encoded data
 
 As a result, the decoder will generate a file named "decoded.out" that contains the decoded data. This should be identical to the file that was encoded.
 
## Technical details
 The encoder binary creates a binary tree called the Huffman tree.
 
By traversing the tree you can extract the encoding codes for each encountered byte in the stream to encode.

I thus needed to save it to a file(or array) in order for the decoder binary to reconstruct the tree from it and use it for decoding.

 One of the challenges was how to transfer the binary tree from memory into a file or an array that I could store in the microcontroller's flash.
 
This also had to be memory efficient.

 Even though this algorithm is used for compression, the funny thing is that sometimes a byte value can get encoded with a code length longer than 8 bits. Of course, this will happen for bytes that have the lowest entropy. This is why sometimes it's necessary to use two bytes for a code representing a singe byte.
 
 The format that I came up with, is the following:
 - byte 1 - contains the length in bits of the code (0 to 16)
 - byte 2 - (optional) contains the code if code length > 0
 - byte 3 - (optional) is the remaining code, if code length > 8
 - these bytes are placed subsequently to describe the code length and the code for every possible byte(0 to 255)
 
 Example of a file(or array) describing the Huffman tree . 
 
 Consider that the file starts with the following bytes:

```
|0x02 0x40| 0x06 0x9c | 0x0 | 0x07 0xba | ....
 ```
 
 It means that byte 0x0 has a code length of 0x02 bits and the code is 01 in binary (the most significant 2 bits of 0x40).
 
 Byte 0x1 has a code length of 0x06 and the code is 100111 in binary (the most significant 6 bits of 0x9c).
 
 Byte 0x2 has a code length of 0 which means that it was not present in the stream that was encoded.
 
 Byte 0x3 has a code length of 0x07 and the code is 1011101 in binary(the most signifcant 7 bits of 0xba)
 
 ...... and so on until we describe all the possible 256 byte values.
 
For each possible byte (0 - 255), the file describing the Huffman tree will need to ouput at most 3 bytes(if code length is > 8), 2 bytes(if 0 < code length < 9) or 1 byte(if code length is 0).

 The maximum size of the file(or array) describing the Huffman tree will be 256 * 3 = 768 bytes.
 
 But since most of the bytes are encoded with code lenghts smaller than 9, the size of the file is smaller.
 
 The *encoded.out* generated file simply concatenates the codes one after the other into bytes.
 
Since the codes are concatenated, the last byte can contain between 1 and 8 bits that represent a whole code or a part of a code. If less than 8 bits are valid for a code, the rest is padded with zeros.

I needed a way to tell the decoder program how many of the bits from the last byte of the encoded file are part of a code.

To solve this, the first byte of the generated encoded file is special because it contains the number of valid bits for a code in the last byte of the file.

Here's an example for when encoding the string *bomber*.

The resulted codes for each of the bytes are:

```
 b(0x62): 0
 
 e(0x65): 100
 
 r(0x72): 101
 
 o(0x6f): 110
 
 m(0x6d): 111
```
The binary sequence for encoding the *bomber* string with the above codes is:

```
01101110100101
```

There are 14 bits in this sequence so we will pad with 2 extra 0 bits to create 2 bytes that we will write to the encoded file:

```
01101110 100101(00) => 0x6e 0x94
```

 The *encoded.out* file resulted contains these 3 bytes:
 ```
 0x06 0x6e 0x94
 ```
 The first byte is 6, indicating that only 6 bits of the last byte are used for a code (8 - 6 = 2 bits that we used for padding)
 The other 2 bytes are 0x6e 0x94, which represent the codes concatenated.
 
 So the 6 bytes message was encoded with 3 bytes.
 
## Using the binaries
 Compile with:
 
 ```make```
 
 Encode file *my-file* with command:
 
 ```./huf-encode-file my-file```
 
 Decode with:
 
 ``` ./huf-decode-file tree.out encoded.out```
 
 The resulted decoded file *decoded.out* should be identical to the encoded file *my-file*
 
## Possible improvements
 - clean the code
 - replace bubble sort from encoder code with a more efficient sorting algorithm
 - possibility to set names to the encoder generated files instead of using hardcoded *tree.out* and *encoded.out* file names
 - probably many more

## Conclusion
It works, but compression rate is not great.
I managed to encode audio samples to 73% - 85% of their original size.

It was a good coding exercise that I also had to do for homework during college days but skipped it (... I know, I know)
 
 
 